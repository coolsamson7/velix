<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="velix API docs, for the Dart programming language.">
  <title>velix - Dart API docs</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">
  
</head>

<body data-base-href="" data-using-base-href="false" class="light-theme">
<div id="overlay-under-drawer"></div>
<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="https://github.com/coolsamson7/velix">velix package</a></li>
  </ol>
  <div class="self-name">velix</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <button class="toggle" id="theme-button" title="Toggle between light and dark mode" aria-label="Light and dark mode toggle">
    <span id="dark-theme-button" class="material-symbols-outlined" aria-hidden="true">
      dark_mode
    </span>
    <span id="light-theme-button" class="material-symbols-outlined" aria-hidden="true">
      light_mode
    </span>
  </button>
</header>
<main>
  <div id="dartdoc-main-content" class="main-content">
      
<section class="desc markdown">
  <p><img src="https://img.shields.io/github/license/coolsamson7/velix" alt="License">
<img src="https://img.shields.io/badge/Dart-3.0-blue" alt="Dart">
<a href="https://coolsamson7.github.io/velix/"><img src="https://img.shields.io/badge/docs-online-blue?logo=github" alt="Docs"></a>
<a href="https://github.com/coolsamson7/velix/actions/workflows/flutter.yaml"><img src="https://github.com/coolsamson7/velix/actions/workflows/flutter.yaml/badge.svg" alt="Flutter CI"></a></p>
<img width="320" height="320" alt="velix" src="https://github.com/user-attachments/assets/21141c08-9a34-4337-88af-173ad2f044a6">
<h1 id="introduction">Introduction</h1>
<p>Velix is Dart/Flutter library implementing some of the core parts required in every Flutter application:</p>
<ul>
<li>type meta data</li>
<li>specification and validation of type constraints</li>
<li>general purpose mapping framework</li>
<li>json mapper</li>
<li>model-based two-way form data-binding</li>
<li>i18n</li>
<li>dependency injection container</li>
<li>command pattern for ui actions</li>
</ul>
<p>Check out some articles on Medium:</p>
<ul>
<li><a href="https://medium.com/@andreas.ernst7/velix-introducing-a-powerful-and-expressive-general-purpose-mapping-and-validation-library-e27a56501604">General purpose mapper</a></li>
<li><a href="https://medium.com/@andreas.ernst7/from-code-to-command-crafting-scalable-and-interceptable-commands-in-flutter-75ed90f136cb">Commands</a></li>
<li><a href="https://medium.com/@andreas.ernst7/model-driven-forms-for-flutter-e0535659489a">Model driven Forms</a></li>
</ul>
<p>Detailed infromation can be found in the corresponding <a href="https://github.com/coolsamson7/velix/wiki">Wiki</a>.</p>
<p>Lets get a quick overview on the topics</p>
<h1 id="validation">Validation</h1>
<p>As in some popular Typescript libraries like <code>yup</code>, it is possible to declare type constraints with a simple fluent language</p>
<pre class="language-dart"><code class="language-dart">var type = IntType().greaterThan(0).lessThan(100);

type.validate(-1); // meeeh....will throw
</code></pre>
<h1 id="type-meta-data">Type Meta-Data</h1>
<p>In combination with a custom code generator, classes decorated with specific annotations - here <code>@Dataclass</code>-  emit the meta data:</p>
<pre class="language-dart"><code class="language-dart">@Dataclass()
class Money {
  // instance data

  @Attribute(type: "length 7")
  final String currency;
  @Attribute(type: "&gt;= 0")
  final int value;

  const Money({required this.currency, required this.value});
}
</code></pre>
<p>The information will be used by a number of mechanisms, such as</p>
<ul>
<li>dependency injection container</li>
<li>the mapping framework</li>
<li>form data-binding.</li>
</ul>
<h1 id="dependency-injection">Dependency Injection</h1>
<p>A DI solution similar based on the existing meta-data has been created, that let's a <strong>container</strong> handle the lifecycle of objects.</p>
<p><strong>Example</strong>:</p>
<pre class="language-Dart"><code class="language-Dart">// a module defines the set of managed objects according to their library location
// it can import other modules!
@Module(imports: [])
class TestModule {
  @Create()
  ConfigurationManager createConfigurationManager() {
    return ConfigurationManager();
  }

  // factory method
  @Create()
  ConfigurationValues createConfigurationValues() {
    // will register with the configuration manager via a lifecycle method!
    return ConfigurationValues({
      "foo": 4711
    });
  }
}

// singleton is the default, btw.
@Injectable(scope: "singleton", eager: false)
class Bar {
  const Bar();
}

// environment means that it is a singleton per environment
@Injectable(scope: "environment")
class Foo {
  // instance data

  final Bar bar;
  
  // constructor injection

  const Foo({required this.bar});
}

@Injectable()
class Factory {
  const Factory();
  
  // some lifecycle callbacks

  // injection of the surrounding environment
  @OnInit()
  void onInit(Environment environment) {
    ...
  }

  @OnDestroy()
  void onDestroy() {
    ...
  }
  
  // config value injection!

  @Inject()
  void setFoo(Foo foo, @Value("foo", defaultValue: 1) int value) {
    ...
  }

  // another method based factory
  @Create() 
  Baz createBaz(Bar bar) {
    return Baz();
  }
}

var environment = Environment(forModule: TestModule);
var foo = environment.get&lt;Foo&gt;();

var inherited = Environment(parent: environment);
var inheritedFoo = environment.get&lt;Foo&gt;(); // will be another instance, since it has the scope "environment"
</code></pre>
<p>Features are:</p>
<ul>
<li>constructor and setter injection</li>
<li>injection of configuration variables</li>
<li>possibility to define custom injections</li>
<li>post processors</li>
<li>support for factory methods</li>
<li>support for eager and lazy construction</li>
<li>support for scopes "singleton", "request" and "environment"</li>
<li>possibility to add custom scopes</li>
<li>conditional registration of classes and factories ( aka profiles in spring )</li>
<li>lifecycle events methods <code>@OnInit</code>, <code>@OnDestroy</code>, <code>@OnRunning</code></li>
<li>Automatic discovery and bundling of injectable objects based on their module location, including support for recursive imports</li>
<li>Instantiation of one or possible more isolated container instances — called environments — each managing the lifecycle of a related set of objects,</li>
<li>Support for hierarchical environments, enabling structured scoping and layered object management.</li>
</ul>
<h1 id="mapping">Mapping</h1>
<p>A general purpose mapping framework let's you declaratively specify mappings:</p>
<pre class="language-dart"><code class="language-dart"> var mapper = Mapper([
        mapping&lt;Money, Money&gt;()
            .map(all: matchingProperties()),

        mapping&lt;Product, Product&gt;()
            .map(from: "status", to: "status")
            .map(from: "name", to: "name")
            .map(from: "price", to: "price", deep: true),

        mapping&lt;Invoice, Invoice&gt;()
            .map(from: "date", to: "date")
            .map(from: "products", to: "products", deep: true)
      ]);

var invoice = Invoice(...);

var result = mapper.map(invoice);
</code></pre>
<p>As a special case, json mapping is supported as well:</p>
<pre class="language-dart"><code class="language-dart">// overall configuration  

JSON(
   validate: true,
   converters: [Convert&lt;DateTime,String&gt;((value) =&gt; value.toIso8601String(), convertTarget: (str) =&gt; DateTime.parse(str))],
   factories: [Enum2StringFactory()]
);

// funny money class

@Dataclass()
@JsonSerializable(includeNull: true) // doesn't make sense here, but anyway...
class Money {
  // instance data

  @Attribute(type: "length 7")
  @Json(name: "c", required: false, defaultValue: "EU")
  final String currency;
  @Json(name="v", required: false, defaultValue: 0)
  @Attribute()
  final int value;

  const Money({required this.currency, this.value});
}

var price = Money(currency: "EU", value: 0);

var json = JSON.serialize(price);
var result = JSON.deserialize&lt;Money&gt;(json);
</code></pre>
<h1 id="commands">Commands</h1>
<p>Commands let's you wrap simple methods in command objects, that</p>
<ul>
<li>are stateful ( enabled / disabled )</li>
<li>can invoke interceptors while being executed ( e.g. exception handling, tracing, ...), and</li>
<li>influence the UI automatically while running ( e.g. spinner fro long-running commands )</li>
</ul>
<pre class="language-dart"><code class="language-dart">class _PersonPageState extends State&lt;PersonPage&gt; with CommandController&lt;PersonPage&gt;, _PersonPageCommands {
   ...
     
  // commands

  @override
  @Command(i18n: "person.details",  icon: CupertinoIcons.save)
  Future&lt;void&gt; _save) async {
      await ... // service call

      updateCommandState();
  }

  // it's always good patternm to have state management in one single place, instead scattered everywhere

  @override
  void updateCommandState() {
    setCommandEnabled("save",  _controller.text.isNotEmpty);
  }
}
</code></pre>
<h1 id="i18n">I18N</h1>
<p>An i18n is implemented with more or less the same scope and api as popular libraries like <code>i18next</code>. but some additional features i haven't found anywhere else.
The solution is made up of two distinct elements.</p>
<p>A <code>LocaleManager</code> is reposonsible to keep track of the current locale.</p>
<p>It is constructed via</p>
<pre class="language-Dart"><code class="language-Dart">LocaleManager(this._currentLocale, {List&lt;Locale&gt;? supportedLocales })
</code></pre>
<p>and can return the current locale via the <code>locale</code> property.
Being a <code>ChangeNotifier</code> - it can inform listeners about any changes of this property,</p>
<p><code>I18N</code> is a class that is used to configure the setup. The constructor accepts the parameters:</p>
<ul>
<li><code> LocaleManager localeManager</code> the locale manager</li>
<li><code> TranslationLoader loader</code> a loader that is used to load localizations</li>
<li><code>Locale? fallbackLocale</code> a fallback locale that will be used for missing keys in the main locale.</li>
<li><code>List&lt;String&gt;? preloadNamespaces</code> list of namespaces to preload</li>
<li><code>List&lt;Formatter&gt;? formatters</code> list of additional fromatter that can be used in the interpolatin process.</li>
<li><code>int cacheSize = 50</code> cache size fro prcomputed interpolation fucntions in a LRU cache</li>
</ul>
<p>After initialization a string extension</p>
<pre class="language-Dart"><code class="language-Dart">tr([Map&lt;String,dynamic&gt;? args])
</code></pre>
<p>can be used to translate keys that consist of a - ":" separated .- namespace and path and optional args.</p>
<p><strong>Example</strong></p>
<pre class="language-Dart"><code class="language-Dart">"app:main.title".tr()
</code></pre>
<pre class="language-Dart"><code class="language-Dart">"app:main.greeting".tr({"user": "Andi"})
</code></pre>
<p>Let's look at the different concepts.</p>
<h2 id="translationloader">TranslationLoader</h2>
<p>The class <code>TranslationLoader</code> is used to load translations.</p>
<pre class="language-Dart"><code class="language-Dart">abstract class TranslationLoader {
  /// load translations given a namespace and a list of locales
  /// [locales] list of [Locale]s that determine the overall result. Starting with the first locale, teh resulting map is computed, the following locales will act as fallbacks, in case of missing keys.
  Future&lt;Map&lt;String, dynamic&gt;&gt; load(List&lt;Locale&gt; locales, String namespace);
}
</code></pre>
<p>The result is a - possibly recursive - map contaning the localizations.</p>
<p>The argument is a list of locales, since we wan't to have a fallback mechanism in case of missing localization values in the main locale.
This list is computed with the following logic:</p>
<ul>
<li>start with the main locale</li>
<li>if the locale has a country code, continue wioth the language code</li>
<li>continue with a possible fallback locale</li>
<li>if the fallback locale has a country code, continue with it's language code</li>
</ul>
<p><strong>Example</strong>: Locale is "de_DE", fallback "en_US"</p>
<p>will result in: <code>["de_DE", "de", "en_US", "en"]</code></p>
<p>Loaders should merge an overall result, starting in the order of the list by only adding values in case of missing entries.</p>
<p><strong>AssetTranslationOrder</strong></p>
<p>The class <code>AssetTranslationOrder</code> is used to load localizations from assets.</p>
<p>Arguments are:</p>
<ul>
<li><code>this.basePath = 'assets/locales'</code> base path for assets</li>
<li><code>Map&lt;String, String&gt;? namespacePackageMap</code> optional map that assigns package names to namespaces</li>
</ul>
<p><strong>Example</strong></p>
<pre class="language-Dart"><code class="language-Dart">{
  "validation": "velix"
}
</code></pre>
<p>tells the loader, that the namespace "validation" is stored in the assets of teh package "velix".</p>
<p>Translations are stored in json files under the locale dir.</p>
<p><strong>Example</strong></p>
<pre class="language-Dart"><code class="language-Dart">assets/
   de/
      validation.json
</code></pre>
<h2 id="interpolation">Interpolation</h2>
<p>Translations can contain placeholders that will be replaced by supplied values. Different  possibilities exist:</p>
<p><strong>variable</strong></p>
<p>"hello {world}!" with arguments <code>{"world": "world"}</code> will result in "hello world!".</p>
<p><strong>variable with format</strong></p>
<p>"{value:number}"</p>
<p>will format numbers given the current locale ( influencing "," or "." in floating point numbers )</p>
<p><strong>variable with format and arguments</strong></p>
<p>"{price:currency(name: 'EUR')}"</p>
<p>Different formatters allow different parameters, with all formatters typically supporting <code>String laccle</code> as a locale code.</p>
<p>Implemented formatters are:</p>
<p><strong>number</strong></p>
<ul>
<li><code>String locale</code></li>
<li><code>int minimumFractionDigits</code> minimum number of digits</li>
<li><code>int maximumFractionDigits</code> maximum number of digits</li>
</ul>
<p><strong>currency</strong></p>
<ul>
<li><code>String locale</code></li>
<li><code>String name</code> name of the currency</li>
</ul>
<p><strong>date</strong></p>
<ul>
<li><code>String locale</code></li>
<li><code>String pattern</code> pattern accoring to the used formatting class <code>DateFormat</code>, e.g. <code>yMMMd</code></li>
</ul>
<p>Unil now, the parameters where part of the template itself. In order to be more flexible, they can also relate to dynamic parameters by prefixing the with "$".</p>
<p><strong>Example</strong>:</p>
<p>Template is: "{price:currency(name: $currencyName)"</p>
<p>and is called with the args <code>{"price": 100, "currencyName": "EUR"}</code></p>
<h2 id="setup">Setup</h2>
<p>A typical setup requires to initialize the main elements:</p>
<pre class="language-Dart"><code class="language-Dart"> var localeManager = LocaleManager(Locale('en', "EN"), supportedLocales: [Locale('en', "EN"), Locale('de', "DE")]);
  var i18n = I18N(
      fallbackLocale: Locale("en", "EN"),
      localeManager: localeManager,
      loader: AssetTranslationLoader(
        namespacePackageMap: {
          "validation": "velix"
        }
      ),
      missingKeyHandler: (key) =&gt; '##$key##',
      preloadNamespaces: ["validation", "example"]
  );

  // load namespaces

  runApp(
    ChangeNotifierProvider.value(
      value: localeManager,
      child: TODOApp(i18n: i18n),
    ),
  );
</code></pre>
<p>and an application running as a locale consumer including some localizationDelegates:</p>
<pre class="language-Dart"><code class="language-Dart"> ...
 child: Consumer&lt;LocaleManager&gt;(
        builder: (BuildContext context, LocaleManager localeManager, Widget? child) {
          return CupertinoApp(
            ...

            // localization

            localizationsDelegates: [I18nDelegate(i18n: i18n), GlobalCupertinoLocalizations.delegate,],
            supportedLocales: localeManager.supportedLocales,
            locale: localeManager.locale
          );
        }
        )
</code></pre>
<h1 id="model-base-form-data-binding">Model-base form data-binding</h1>
<h2 id="motivation">Motivation</h2>
<p>Looking at the effort required in Flutter to handle even simple forms i was shocked and started looking for
alternatives that gave my about the same level of verbosity or productivity as i have known for example in Angular.</p>
<p>While there are some form related libraries, they all skip the problem of binding widgets to values automatically, so i started my own
library reusing ideas, that i have known for at least 20 years :-)
Starting with the form binding quickly other solutions where integrated as well, that simplify development.</p>
<h2 id="solution-idea">Solution idea</h2>
<p>The idea is a model based declarative approach, that utilizes</p>
<ul>
<li>reflection information with respect to the bound classes and fields</li>
<li>including type constraints on field level</li>
<li>in combination with technical adapters that handle specific widgets and do the internal dirty work.</li>
</ul>
<p>As a result, all the typical boilerplate code is completely gone, resulting in a fraction of necessary code.</p>
<p><strong>Example</strong></p>
<p>Let's look at a simple form example first.</p>
<p>Both the reflection and validation information is covered by specific decorators:</p>
<pre class="language-dart"><code class="language-dart">@Dataclass()
class Address {
  // instance data

  @Attribute(type: "length 100")
  final String city;
  @Attribute(type: "length 100")
  final String street;
  
  // constructor

  Address({required this.city, required this.street});
}

@Dataclass()
class Person {
  // instance data

  @Attribute(type: "length 100")
  String firstName;
  @Attribute(type: "length 100")
  String lastName;
  @Attribute(type: "&gt;= 0")
  int age;
  @Attribute()
  Address address;
}
</code></pre>
<p>Inside the state of the form page, we can bind values easily</p>
<pre class="language-dart"><code class="language-dart">class PersonFormPageState extends State&lt;PersonFormPage&gt; {
  // instance data

  late FormMapper mapper;
  
  // override

  @override
  void initState() {
    super.initState();

    mapper = FormMapper(instance: widget.person, twoWay: true);

    mapper.isDirty.addListener(() {
      setState(() {
      });
    });
  }

  @override
  void dispose() {
    super.dispose();

    mapper.dispose();
  }

  @override
  Widget build(BuildContext context) {

    Widget result = SmartForm(
      autovalidateMode: AutovalidateMode.onUserInteraction,
      key: mapper.getKey(),
      ...
      mapper.text(path: "firstName", context: context, placeholder: 'First Name'), 
      mapper.text(path: "lastName", context: context, placeholder: 'Last Name'),
      mapper.text(path: "age", context: context, placeholder: 'Age'),
      mapper.text(path: "address.city", context: context, placeholder: 'City'),
      mapper.text(path: "address.street", context: context, placeholder: 'Street'),
    );

    // set value

    mapper.setValue(widget.person);

    // done

    return result;
  }
} 
</code></pre>
<p>You can already see some highlights:</p>
<ul>
<li>automatic handling of type validation ( e.g. length constraints ) and generation of error messages</li>
<li>automatic coercion of types ( e.g. "age" is bound to a text field )</li>
<li>handling of paths ( "address.city" ) including the necessary reconstruction of immutable classes ( with final fields )</li>
<li>two-way data-binding, if requested</li>
</ul>
<p>Two-way databinding will modify the underlying model immediately after every change in a associated widget.
If disabled, you would have to explicitly call <code>form.getValue()</code> to retrieve the updated model. The additional benefit you
would gain here is that the form mapper remembers the initial values and will change its <code>dirty</code> state accordingly, which means that
a reverted change will bring the form back to a non-dirty state!</p>
<h2 id="benefits">Benefits</h2>
<p>Velix drastically reduces the manual wiring and repetitive boilerplate that normally comes with Flutter forms.
With it, you get:</p>
<ul>
<li>
<p>No manual controllers – Forget TextEditingController, FocusNode, and onChanged spaghetti for every single field.</p>
</li>
<li>
<p>Type-aware validation out of the box – Your @Attribute metadata drives validation rules automatically, without repeating them in the UI layer.</p>
</li>
<li>
<p>Immutable model support – Handles reconstruction of immutable (final) classes automatically when updating nested fields.</p>
</li>
<li>
<p>Two-way binding – Keep your widgets and model in sync without extra glue code; or opt for one-way binding with explicit getValue() retrieval.</p>
</li>
<li>
<p>Path-based binding – Easily bind deeply nested fields (address.city) without manually drilling down in your widget code.</p>
</li>
<li>
<p>Automatic dirty-state tracking – Know instantly if a form has unsaved changes and when it has been reverted to its original state.</p>
</li>
<li>
<p>Minimal code footprint – Complex forms can be expressed in a fraction of the lines you’d normally need.</p>
</li>
</ul>
<h2 id="comparison-to-existing-flutter-solutions">Comparison to Existing Flutter Solutions</h2>
<p>While Flutter has some established form libraries like
flutter_form_builder and reactive_forms, they still expect you to:</p>
<ul>
<li>
<p>Define FormControl or TextEditingController instances manually</p>
</li>
<li>
<p>Wire each widget to its controller or form control</p>
</li>
<li>
<p>Duplicate validation rules across model and UI layers</p>
</li>
<li>
<p>Write boilerplate for converting between text and typed fields</p>
</li>
</ul>
<p>Velix takes a different route:</p>
<ul>
<li>
<p>Model-driven – The form is generated from your annotated model, not from widget-level configuration.</p>
</li>
<li>
<p>Automatic widget adapters – You don’t manually connect a controller; you just tell Velix which property to bind.</p>
</li>
<li>
<p>Unified validation &amp; transformation – Rules live once, in the model, and apply everywhere.</p>
</li>
<li>
<p>Nested object awareness – Works with object graphs, not just flat maps of fields.</p>
</li>
</ul>
<p>The result is a WPF/Angular-style binding experience in Flutter — something currently missing from the ecosystem.</p>
<h1 id="installation">Installation</h1>
<p>The library is published on <a href="https://pub.dev/packages/velix">pub.dev</a></p>
</section>


      <section class="summary">
          <h2>Libraries</h2>
        <dl>
          <dt id="command">
  <span class="name"><a href="commands_command/">commands/command</a></span> 

</dt>
<dd>
</dd>

          <dt id="command_button">
  <span class="name"><a href="components_command_button/">components/command_button</a></span> 

</dt>
<dd>
</dd>

          <dt id="command_toolbar">
  <span class="name"><a href="components_command_toolbar/">components/command_toolbar</a></span> 

</dt>
<dd>
</dd>

          <dt id="overlay">
  <span class="name"><a href="components_overlay/">components/overlay</a></span> 

</dt>
<dd>
</dd>

          <dt id="view">
  <span class="name"><a href="components_view/">components/view</a></span> 

</dt>
<dd>
</dd>

          <dt id="configuration">
  <span class="name"><a href="configuration_configuration/">configuration/configuration</a></span> 

</dt>
<dd>
</dd>

          <dt id="json_source">
  <span class="name"><a href="configuration_source_json_source/">configuration/source/json_source</a></span> 

</dt>
<dd>
</dd>

          <dt id="form_mapper">
  <span class="name"><a href="databinding_form_mapper/">databinding/form_mapper</a></span> 

</dt>
<dd>
</dd>

          <dt id="valued_widget">
  <span class="name"><a href="databinding_valued_widget/">databinding/valued_widget</a></span> 

</dt>
<dd>
</dd>

          <dt id="widgets">
  <span class="name"><a href="databinding_widgets/">databinding/widgets</a></span> 

</dt>
<dd>
</dd>

          <dt id="checkbox">
  <span class="name"><a href="databinding_widgets_cupertino_checkbox/">databinding/widgets/cupertino/checkbox</a></span> 

</dt>
<dd>
</dd>

          <dt id="datepicker">
  <span class="name"><a href="databinding_widgets_cupertino_datepicker/">databinding/widgets/cupertino/datepicker</a></span> 

</dt>
<dd>
</dd>

          <dt id="registry">
  <span class="name"><a href="databinding_widgets_cupertino_registry/">databinding/widgets/cupertino/registry</a></span> 

</dt>
<dd>
</dd>

          <dt id="slider">
  <span class="name"><a href="databinding_widgets_cupertino_slider/">databinding/widgets/cupertino/slider</a></span> 

</dt>
<dd>
</dd>

          <dt id="switch">
  <span class="name"><a href="databinding_widgets_cupertino_switch/">databinding/widgets/cupertino/switch</a></span> 

</dt>
<dd>
</dd>

          <dt id="text">
  <span class="name"><a href="databinding_widgets_cupertino_text/">databinding/widgets/cupertino/text</a></span> 

</dt>
<dd>
</dd>

          <dt id="checkbox">
  <span class="name"><a href="databinding_widgets_material_checkbox/">databinding/widgets/material/checkbox</a></span> 

</dt>
<dd>
</dd>

          <dt id="datepicker">
  <span class="name"><a href="databinding_widgets_material_datepicker/">databinding/widgets/material/datepicker</a></span> 

</dt>
<dd>
</dd>

          <dt id="registry">
  <span class="name"><a href="databinding_widgets_material_registry/">databinding/widgets/material/registry</a></span> 

</dt>
<dd>
</dd>

          <dt id="slider">
  <span class="name"><a href="databinding_widgets_material_slider/">databinding/widgets/material/slider</a></span> 

</dt>
<dd>
</dd>

          <dt id="switch">
  <span class="name"><a href="databinding_widgets_material_switch/">databinding/widgets/material/switch</a></span> 

</dt>
<dd>
</dd>

          <dt id="text">
  <span class="name"><a href="databinding_widgets_material_text/">databinding/widgets/material/text</a></span> 

</dt>
<dd>
</dd>

          <dt id="text">
  <span class="name"><a href="databinding_widgets_text/">databinding/widgets/text</a></span> 

</dt>
<dd>
</dd>

          <dt id="di">
  <span class="name"><a href="di_di/">di/di</a></span> 

</dt>
<dd>
</dd>

          <dt id="date_formatter">
  <span class="name"><a href="i18n_formatter_date_formatter/">i18n/formatter/date_formatter</a></span> 

</dt>
<dd>
</dd>

          <dt id="number_formatter">
  <span class="name"><a href="i18n_formatter_number_formatter/">i18n/formatter/number_formatter</a></span> 

</dt>
<dd>
</dd>

          <dt id="i18n">
  <span class="name"><a href="i18n_i18n/">i18n/i18n</a></span> 

</dt>
<dd>
</dd>

          <dt id="interpolator">
  <span class="name"><a href="i18n_interpolator/">i18n/interpolator</a></span> 

</dt>
<dd>
</dd>

          <dt id="asset_loader">
  <span class="name"><a href="i18n_loader_asset_loader/">i18n/loader/asset_loader</a></span> 

</dt>
<dd>
</dd>

          <dt id="locale">
  <span class="name"><a href="i18n_locale/">i18n/locale</a></span> 

</dt>
<dd>
</dd>

          <dt id="translator">
  <span class="name"><a href="i18n_translator/">i18n/translator</a></span> 

</dt>
<dd>
</dd>

          <dt id="json">
  <span class="name"><a href="mapper_json/">mapper/json</a></span> 

</dt>
<dd>
</dd>

          <dt id="mapper">
  <span class="name"><a href="mapper_mapper/">mapper/mapper</a></span> 

</dt>
<dd>
</dd>

          <dt id="operation_builder">
  <span class="name"><a href="mapper_operation_builder/">mapper/operation_builder</a></span> 

</dt>
<dd>
</dd>

          <dt id="transformer">
  <span class="name"><a href="mapper_transformer/">mapper/transformer</a></span> 

</dt>
<dd>
</dd>

          <dt id="reflectable">
  <span class="name"><a href="reflectable_reflectable/">reflectable/reflectable</a></span> 

</dt>
<dd>
</dd>

          <dt id="collections">
  <span class="name"><a href="util_collections/">util/collections</a></span> 

</dt>
<dd>
</dd>

          <dt id="tracer">
  <span class="name"><a href="util_tracer/">util/tracer</a></span> 

</dt>
<dd>
</dd>

          <dt id="validation">
  <span class="name"><a href="validation_validation/">validation/validation</a></span> 

</dt>
<dd>
</dd>

          <dt id="velix">
  <span class="name"><a href="velix/">velix</a></span> 

</dt>
<dd>
</dd>

        </dl>
      </section>
  </div> <!-- /.main-content -->
  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <!-- The search input and breadcrumbs below are only responsively visible at low resolutions. -->
<header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>
<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
    <li><a href="https://github.com/coolsamson7/velix">velix package</a></li>
</ol>

    <h5 class="hidden-xs"><span class="package-name">velix</span> <span class="package-kind">package</span></h5>
    <ol>
      <li class="section-title">Libraries</li>
      <li><a href="commands_command/">commands/command</a></li>
      <li><a href="components_command_button/">components/command_button</a></li>
      <li><a href="components_command_toolbar/">components/command_toolbar</a></li>
      <li><a href="components_overlay/">components/overlay</a></li>
      <li><a href="components_view/">components/view</a></li>
      <li><a href="configuration_configuration/">configuration/configuration</a></li>
      <li><a href="configuration_source_json_source/">configuration/source/json_source</a></li>
      <li><a href="databinding_form_mapper/">databinding/form_mapper</a></li>
      <li><a href="databinding_valued_widget/">databinding/valued_widget</a></li>
      <li><a href="databinding_widgets/">databinding/widgets</a></li>
      <li><a href="databinding_widgets_cupertino_checkbox/">databinding/widgets/cupertino/checkbox</a></li>
      <li><a href="databinding_widgets_cupertino_datepicker/">databinding/widgets/cupertino/datepicker</a></li>
      <li><a href="databinding_widgets_cupertino_registry/">databinding/widgets/cupertino/registry</a></li>
      <li><a href="databinding_widgets_cupertino_slider/">databinding/widgets/cupertino/slider</a></li>
      <li><a href="databinding_widgets_cupertino_switch/">databinding/widgets/cupertino/switch</a></li>
      <li><a href="databinding_widgets_cupertino_text/">databinding/widgets/cupertino/text</a></li>
      <li><a href="databinding_widgets_material_checkbox/">databinding/widgets/material/checkbox</a></li>
      <li><a href="databinding_widgets_material_datepicker/">databinding/widgets/material/datepicker</a></li>
      <li><a href="databinding_widgets_material_registry/">databinding/widgets/material/registry</a></li>
      <li><a href="databinding_widgets_material_slider/">databinding/widgets/material/slider</a></li>
      <li><a href="databinding_widgets_material_switch/">databinding/widgets/material/switch</a></li>
      <li><a href="databinding_widgets_material_text/">databinding/widgets/material/text</a></li>
      <li><a href="databinding_widgets_text/">databinding/widgets/text</a></li>
      <li><a href="di_di/">di/di</a></li>
      <li><a href="i18n_formatter_date_formatter/">i18n/formatter/date_formatter</a></li>
      <li><a href="i18n_formatter_number_formatter/">i18n/formatter/number_formatter</a></li>
      <li><a href="i18n_i18n/">i18n/i18n</a></li>
      <li><a href="i18n_interpolator/">i18n/interpolator</a></li>
      <li><a href="i18n_loader_asset_loader/">i18n/loader/asset_loader</a></li>
      <li><a href="i18n_locale/">i18n/locale</a></li>
      <li><a href="i18n_translator/">i18n/translator</a></li>
      <li><a href="mapper_json/">mapper/json</a></li>
      <li><a href="mapper_mapper/">mapper/mapper</a></li>
      <li><a href="mapper_operation_builder/">mapper/operation_builder</a></li>
      <li><a href="mapper_transformer/">mapper/transformer</a></li>
      <li><a href="reflectable_reflectable/">reflectable/reflectable</a></li>
      <li><a href="util_collections/">util/collections</a></li>
      <li><a href="util_tracer/">util/tracer</a></li>
      <li><a href="validation_validation/">validation/validation</a></li>
      <li><a href="velix/">velix</a></li>
</ol>

  </div>
  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div>
</main>
<footer>
  <span class="no-break">
    velix
      0.18.1
  </span>
  
</footer>


<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>

</body>
</html>

